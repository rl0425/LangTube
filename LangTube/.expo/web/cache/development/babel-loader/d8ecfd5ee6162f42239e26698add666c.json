{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nvar BASE_URL = \"http://192.168.0.3:3333\";\nexport var api = function api(url, method) {\n  var body,\n      headers,\n      endPoint,\n      reqBody,\n      fetchParams,\n      fetchPromise,\n      timeOutPromise,\n      response,\n      _args = arguments;\n  return _regeneratorRuntime.async(function api$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          body = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;\n          headers = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n          _context.prev = 2;\n          endPoint = BASE_URL.concat(url);\n          reqBody = body ? JSON.stringify(body) : null;\n          fetchParams = {\n            method: method,\n            headers: headers\n          };\n\n          if (!((method === \"POST\" || method === \"PUT\") && !reqBody)) {\n            _context.next = 8;\n            break;\n          }\n\n          throw new Error(\"Request body required\");\n\n        case 8:\n          if (reqBody) {\n            fetchParams.headers[\"Content-type\"] = \"application/json\";\n            fetchParams.body = reqBody;\n          }\n\n          fetchPromise = fetch(endPoint, fetchParams);\n          timeOutPromise = new Promise(function (resolve, reject) {\n            setTimeout(function () {\n              reject(\"Request Timeout\");\n            }, 3000);\n          });\n          _context.next = 13;\n          return _regeneratorRuntime.awrap(Promise.race([fetchPromise, timeOutPromise]));\n\n        case 13:\n          response = _context.sent;\n          return _context.abrupt(\"return\", response);\n\n        case 17:\n          _context.prev = 17;\n          _context.t0 = _context[\"catch\"](2);\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 20:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[2, 17]], Promise);\n};\nexport var fetchApi = function fetchApi(url, method, body, statusCode) {\n  var token,\n      loader,\n      headers,\n      result,\n      response,\n      responseBody,\n      responseText,\n      errorBody,\n      errorText,\n      _args2 = arguments;\n  return _regeneratorRuntime.async(function fetchApi$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          token = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : null;\n          loader = _args2.length > 5 && _args2[5] !== undefined ? _args2[5] : false;\n          _context2.prev = 2;\n          headers = {};\n          result = {\n            token: null,\n            success: false,\n            responseBody: null\n          };\n\n          if (token) {\n            headers[\"x-auth\"] = token;\n          }\n\n          _context2.next = 8;\n          return _regeneratorRuntime.awrap(api(url, method, body, headers));\n\n        case 8:\n          response = _context2.sent;\n\n          if (!(response.status === statusCode)) {\n            _context2.next = 18;\n            break;\n          }\n\n          result.success = true;\n\n          if (response.headers.get(\"x-auth\")) {\n            result.token = response.headers.get(\"x-auth\");\n          }\n\n          _context2.next = 14;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 14:\n          responseText = _context2.sent;\n\n          try {\n            responseBody = JSON.parse(responseText);\n          } catch (e) {\n            responseBody = responseText;\n          }\n\n          result.responseBody = responseBody;\n          return _context2.abrupt(\"return\", result);\n\n        case 18:\n          _context2.next = 20;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 20:\n          errorText = _context2.sent;\n\n          try {\n            errorBody = JSON.parse(errorText);\n          } catch (e) {\n            errorBody = errorText;\n          }\n\n          result.responseBody = errorBody;\n          console.log(result);\n          throw result;\n\n        case 27:\n          _context2.prev = 27;\n          _context2.t0 = _context2[\"catch\"](2);\n          return _context2.abrupt(\"return\", _context2.t0);\n\n        case 30:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[2, 27]], Promise);\n};","map":{"version":3,"sources":["C:/Users/parkgichan/Desktop/자기소개서/langtube/Rangtube/source/service/api.js"],"names":["BASE_URL","api","url","method","body","headers","endPoint","concat","reqBody","JSON","stringify","fetchParams","Error","fetchPromise","fetch","timeOutPromise","Promise","resolve","reject","setTimeout","race","response","fetchApi","statusCode","token","loader","result","success","responseBody","status","get","text","responseText","parse","e","errorText","errorBody","console","log"],"mappings":"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","sourcesContent":["/** api는 특정 경로의 특정메소드로 들어오는 요청을 받고 요청 값에 따라 다른 결과를 response */\r\n/** 이때 response의 형태는 JSON */\r\n/** 서버와 통신을 위한 연결 */\r\n\r\nconst BASE_URL = \"http://192.168.0.3:3333\";\r\n\r\nexport const api = async (url, method, body = null, headers = {}) => {\r\n\r\n    try {\r\n      const endPoint = BASE_URL.concat(url);\r\n      const reqBody = body ? JSON.stringify(body) : null;\r\n\r\n      const fetchParams = {method, headers};\r\n\r\n      if((method === \"POST\" || method === \"PUT\") && !reqBody) {\r\n          throw new Error(\"Request body required\");\r\n      }\r\n\r\n      if(reqBody) {\r\n          fetchParams.headers[\"Content-type\"] = \"application/json\";\r\n          fetchParams.body = reqBody;\r\n      }\r\n\r\n      const fetchPromise = fetch(endPoint, fetchParams);\r\n      const timeOutPromise = new Promise((resolve, reject) => {\r\n          setTimeout(() => {\r\n              reject(\"Request Timeout\");\r\n          }, 3000);\r\n      });\r\n\r\n      const response = await Promise.race([fetchPromise, timeOutPromise]);\r\n\r\n      return response;\r\n    } catch (e) {\r\n      return e;\r\n    }\r\n}\r\n\r\nexport const fetchApi = async (url, method, body, statusCode, token = null, loader = false) => {\r\n    try {\r\n        const headers = {}\r\n        const result = {\r\n            token: null,\r\n            success: false,\r\n            responseBody: null\r\n        };\r\n        if(token) {\r\n            headers[\"x-auth\"] = token;\r\n        }\r\n\r\n        const response = await api(url, method, body, headers);\r\n\r\n        //console.log(response);\r\n\r\n        if(response.status === statusCode) {\r\n            result.success = true;\r\n\r\n            if(response.headers.get(\"x-auth\")) {\r\n                result.token = response.headers.get(\"x-auth\");\r\n            }\r\n\r\n            let responseBody;\r\n            const responseText = await response.text();\r\n\r\n            try {\r\n                responseBody = JSON.parse(responseText);\r\n            } catch (e) {\r\n                responseBody = responseText;\r\n            }\r\n\r\n            result.responseBody = responseBody;\r\n            return result;\r\n\r\n        }\r\n\r\n        let errorBody;\r\n        const errorText = await response.text();\r\n\r\n        try {\r\n            errorBody = JSON.parse(errorText);\r\n        } catch (e) {\r\n            errorBody = errorText;\r\n        }\r\n\r\n        result.responseBody = errorBody;\r\n\r\n        console.log(result);\r\n\r\n        throw result;\r\n    } catch (error) {\r\n        return error;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}